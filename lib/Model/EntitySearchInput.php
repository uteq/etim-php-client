<?php
/**
 * EntitySearchInput
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * ETIM API
 *
 * ETIM International webservices.       - [Extra documentation and testclient](https://bitbucket.org/3xt/etimapi-rest-client/src/master/)
 *
 * OpenAPI spec version: 2.0
 * Contact: info@etim-international.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.23
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * EntitySearchInput Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EntitySearchInput implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'EntitySearchInput';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'from' => 'int',
'size' => 'int',
'languagecode' => 'string',
'search_string' => 'string',
'deprecated' => 'bool',
'modelling' => 'bool',
'include' => '\Swagger\Client\Model\IncludeModel',
'filters' => '\Swagger\Client\Model\FilterModel[]'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'from' => 'int32',
'size' => 'int32',
'languagecode' => null,
'search_string' => null,
'deprecated' => null,
'modelling' => null,
'include' => null,
'filters' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'from' => 'from',
'size' => 'size',
'languagecode' => 'languagecode',
'search_string' => 'searchString',
'deprecated' => 'deprecated',
'modelling' => 'modelling',
'include' => 'include',
'filters' => 'filters'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'from' => 'setFrom',
'size' => 'setSize',
'languagecode' => 'setLanguagecode',
'search_string' => 'setSearchString',
'deprecated' => 'setDeprecated',
'modelling' => 'setModelling',
'include' => 'setInclude',
'filters' => 'setFilters'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'from' => 'getFrom',
'size' => 'getSize',
'languagecode' => 'getLanguagecode',
'search_string' => 'getSearchString',
'deprecated' => 'getDeprecated',
'modelling' => 'getModelling',
'include' => 'getInclude',
'filters' => 'getFilters'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['from'] = isset($data['from']) ? $data['from'] : null;
        $this->container['size'] = isset($data['size']) ? $data['size'] : null;
        $this->container['languagecode'] = isset($data['languagecode']) ? $data['languagecode'] : null;
        $this->container['search_string'] = isset($data['search_string']) ? $data['search_string'] : null;
        $this->container['deprecated'] = isset($data['deprecated']) ? $data['deprecated'] : null;
        $this->container['modelling'] = isset($data['modelling']) ? $data['modelling'] : null;
        $this->container['include'] = isset($data['include']) ? $data['include'] : null;
        $this->container['filters'] = isset($data['filters']) ? $data['filters'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['from'] === null) {
            $invalidProperties[] = "'from' can't be null";
        }
        if ($this->container['size'] === null) {
            $invalidProperties[] = "'size' can't be null";
        }
        if ($this->container['languagecode'] === null) {
            $invalidProperties[] = "'languagecode' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets from
     *
     * @return int
     */
    public function getFrom()
    {
        return $this->container['from'];
    }

    /**
     * Sets from
     *
     * @param int $from Startposition for paging.  From must be less than or equal to 19000. From + size must be less than or equal to 20000
     *
     * @return $this
     */
    public function setFrom($from)
    {
        $this->container['from'] = $from;

        return $this;
    }

    /**
     * Gets size
     *
     * @return int
     */
    public function getSize()
    {
        return $this->container['size'];
    }

    /**
     * Sets size
     *
     * @param int $size Total records per page  Size must be less than or equal to 1000. From + size must be less than or equal to 20000
     *
     * @return $this
     */
    public function setSize($size)
    {
        $this->container['size'] = $size;

        return $this;
    }

    /**
     * Gets languagecode
     *
     * @return string
     */
    public function getLanguagecode()
    {
        return $this->container['languagecode'];
    }

    /**
     * Sets languagecode
     *
     * @param string $languagecode Language of the output description fields.   Language of the input SearchString if used
     *
     * @return $this
     */
    public function setLanguagecode($languagecode)
    {
        $this->container['languagecode'] = $languagecode;

        return $this;
    }

    /**
     * Gets search_string
     *
     * @return string
     */
    public function getSearchString()
    {
        return $this->container['search_string'];
    }

    /**
     * Sets search_string
     *
     * @param string $search_string Search with a specific text in description or synonym
     *
     * @return $this
     */
    public function setSearchString($search_string)
    {
        $this->container['search_string'] = $search_string;

        return $this;
    }

    /**
     * Gets deprecated
     *
     * @return bool
     */
    public function getDeprecated()
    {
        return $this->container['deprecated'];
    }

    /**
     * Sets deprecated
     *
     * @param bool $deprecated Some entities (features, values and units) can be deprecated. This means they may not be used anymore in future.  If not set, return both deprecated and not deprecated entities  If Deprecated = true, return only deprecated entities  If Deprecated = false, return only entities that are not deprecated  Only applicable for features, values and units
     *
     * @return $this
     */
    public function setDeprecated($deprecated)
    {
        $this->container['deprecated'] = $deprecated;

        return $this;
    }

    /**
     * Gets modelling
     *
     * @return bool
     */
    public function getModelling()
    {
        return $this->container['modelling'];
    }

    /**
     * Sets modelling
     *
     * @param bool $modelling Some classes are special Modelling classes. Modelling classes start with MC******  If not set, return both Modelling (MC) and Regular (EC) classes  If Modelling = true, return only modelling classes  If Modelling = false, return only regular classes  Only applicable for classes
     *
     * @return $this
     */
    public function setModelling($modelling)
    {
        $this->container['modelling'] = $modelling;

        return $this;
    }

    /**
     * Gets include
     *
     * @return \Swagger\Client\Model\IncludeModel
     */
    public function getInclude()
    {
        return $this->container['include'];
    }

    /**
     * Sets include
     *
     * @param \Swagger\Client\Model\IncludeModel $include include
     *
     * @return $this
     */
    public function setInclude($include)
    {
        $this->container['include'] = $include;

        return $this;
    }

    /**
     * Gets filters
     *
     * @return \Swagger\Client\Model\FilterModel[]
     */
    public function getFilters()
    {
        return $this->container['filters'];
    }

    /**
     * Sets filters
     *
     * @param \Swagger\Client\Model\FilterModel[] $filters Use filters to filter the results
     *
     * @return $this
     */
    public function setFilters($filters)
    {
        $this->container['filters'] = $filters;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
